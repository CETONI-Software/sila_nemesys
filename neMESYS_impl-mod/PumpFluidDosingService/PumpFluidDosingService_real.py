"""
________________________________________________________________________

:PROJECT: SiLA2_python

*Pump Fluid Dosing Service*

:details: PumpFluidDosingService:
    Allows to dose a specified fluid. There are commands for absolute dosing (SetFillLevel) and relative dosing
    (DoseVolume and GenerateFlow) available.The flow rate can be negative. In this case the pump aspirates the fluid
    instead of dispensing. The flow rate has to be a value between MaxFlowRate and MinFlowRate. If the value is not
    within this range (hence is invalid) a ValidationError will be thrown.
    At any time the property CurrentSyringeFillLevel can be queried to see how much fluid is left in the syringe.
    Similarly the property CurrentFlowRate can be queried to get the current flow rate at which the pump is dosing.

:file:    PumpFluidDosingService_real.py
:authors: Florian Meinicke

:date: (creation)          2019-07-16T11:11:31.305142
:date: (last modification) 2019-07-16T11:11:31.305142

.. note:: Code generated by SiLA2CodeGenerator 0.2.0

________________________________________________________________________

**Copyright**:
  This file is provided "AS IS" with NO WARRANTY OF ANY KIND,
  INCLUDING THE WARRANTIES OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

  For further Information see LICENSE file that comes with this distribution.
________________________________________________________________________
"""

__version__ = "0.0.1"

# import general packages
import logging
import uuid
import time

# import SiLA2 library
import sila2lib.SiLAFramework_pb2 as fwpb2

# import gRPC modules for this feature
from .gRPC import PumpFluidDosingService_pb2 as pb2
from .gRPC import PumpFluidDosingService_pb2_grpc as pb2_grpc

# import default arguments
from .PumpFluidDosingService_default_arguments import default_dict


# noinspection PyPep8Naming
class PumpFluidDosingServiceReal:
    """
    Implementation of the *Pump Fluid Dosing Service* in *Real* mode
        This is a test service for neMESYS syringe pumps via SiLA2
    """

    def __init__(self):
        """Class initialiser"""

        logging.debug('Started server in mode: {mode}'.format(mode='Real'))

    def _get_command_state(self, command_uuid: str) -> fwpb2.ExecutionInfo:
        """

        :param command_uuid: The uuid of the command for which to return the current state

        :return: An execution info object with the current command state
        """

        #: Enumeration of fwpb2.ExecutionInfo.CommandStatus
        command_status = fwpb2.ExecutionInfo.CommandStatus.waiting
        #: Real fwpb2.Real(0...1)
        command_progress = None
        #: Duration fwpb2.Duration(seconds=<seconds>, nanos=<nanos>)
        command_estimated_remaining = None
        #: Duration fwpb2.Duration(seconds=<seconds>, nanos=<nanos>)
        command_lifetime_of_execution = None

        # just return a default in this example
        return fwpb2.ExecutionInfo(
            commandStatus=command_status,
            progressInfo=(
                command_progress if command_progress is not None else None
            ),
            estimatedRemainingTime=(
                command_estimated_remaining if command_estimated_remaining is not None else None
            ),
            updatedLifetimeOfExecution=(
                command_lifetime_of_execution if command_lifetime_of_execution is not None else None
            )
        )

    def SetFillLevel(self, request, context) -> fwpb2.CommandConfirmation:
        """
        Executes the observable command Set Fill Level
            Pumps fluid with the given flow rate until the requested fill level is reached.
            Depending on the requested fill level given in the FillLevel parameter this function may cause aspiration or dispension of fluid.
    
        :param request: gRPC request containing the parameters passed:
            request.FillLevel (Fill Level):
            The requested fill level. A level of 0 indicates a completely empty syringe. The value has to be between 0 and MaxSyringeFillLevel or else a ValidationError will be thrown.
            request.FlowRate (Flow Rate):
            The flow rate at which the pump should dose the fluid. This value can be negative. In that case the pump aspirates the fluid.
        :param context: gRPC :class:`~grpc.ServicerContext` object providing gRPC-specific information
    
        :returns: A command confirmation object with the following information:
            commandId: A command id with which this observable command can be referenced in future calls
            lifetimeOfExecution: The (maximum) lifetime of this command call.
        """
    
        # initialise default values
        #: Duration fwpb2.Duration(seconds=<seconds>, nanos=<nanos>)
        lifetime_of_execution: fwpb2.Duration = None
    
        # TODO:
        #   Execute the actual command
        #   Optional: Generate a lifetime_of_execution
    
        # respond with UUID and lifetime of execution
        command_uuid = fwpb2.CommandExecutionUUID(commandId=str(uuid.uuid4()))
        if lifetime_of_execution is not None:
            return fwpb2.CommandConfirmation(
                commandId=command_uuid,
                lifetimeOfExecution=lifetime_of_execution
            )
        else:
            return fwpb2.CommandConfirmation(
                commandId=command_uuid
            )
    
    def SetFillLevel_Info(self, request, context) -> fwpb2.ExecutionInfo:
        """
        Returns execution information regarding the command call :meth:`~.SetFillLevel`.
    
        :param request: A request object with the following properties
            commandId: The UUID of the command executed.
        :param context: gRPC :class:`~grpc.ServicerContext` object providing gRPC-specific information
    
        :returns: An ExecutionInfo response stream for the command with the following fields:
            commandStatus: Status of the command (enumeration)
            progressInfo: Information on the progress of the command (0 to 1)
            estimatedRemainingTime: Estimate of the remaining time required to run the command
            updatedLifetimeOfExecution: An update on the execution lifetime
        """
        # Get the UUID of the command
        command_uuid = request.commandId
    
        # Get the current state
        execution_info = self._get_command_state(command_uuid=command_uuid)
    
        # construct the initial return dictionary in case while is not executed
        return_values = {'commandStatus': execution_info.commandStatus}
        if execution_info.HasField('progressInfo'):
            return_values['progressInfo'] = execution_info.progressInfo
        if execution_info.HasField('estimatedRemainingTime'):
            return_values['estimatedRemainingTime'] = execution_info.estimatedRemainingTime
        if execution_info.HasField('updatedLifetimeOfExecution'):
            return_values['updatedLifetimeOfExecution'] = execution_info.updatedLifetimeOfExecution
    
        # we loop only as long as the command is running
        while execution_info.commandStatus == fwpb2.ExecutionInfo.CommandStatus.waiting \
                or execution_info.commandStatus == fwpb2.ExecutionInfo.CommandStatus.running:
            # TODO:
            #   Evaluate the command status --> command_status. Options:
            #       command_stats = fwpb2.ExecutionInfo.CommandStatus.waiting
            #       command_stats = fwpb2.ExecutionInfo.CommandStatus.running
            #       command_stats = fwpb2.ExecutionInfo.CommandStatus.finishedSuccessfully
            #       command_stats = fwpb2.ExecutionInfo.CommandStatus.finishedWithError
            #   Optional:
            #       * Determine the progress (progressInfo)
            #       * Determine the estimated remaining time
            #       * Update the Lifetime of execution
    
            # Update all values
            execution_info = self._get_command_state(command_uuid=command_uuid)
    
            # construct the return dictionary
            return_values = {'commandStatus': execution_info.commandStatus}
            if execution_info.HasField('progressInfo'):
                return_values['progressInfo'] = execution_info.progressInfo
            if execution_info.HasField('estimatedRemainingTime'):
                return_values['estimatedRemainingTime'] = execution_info.estimatedRemainingTime
            if execution_info.HasField('updatedLifetimeOfExecution'):
                return_values['updatedLifetimeOfExecution'] = execution_info.updatedLifetimeOfExecution
    
            yield fwpb2.ExecutionInfo(**return_values)
    
            # we add a small delay to give the client a chance to keep up.
            time.sleep(0.5)
        else:
            # one last time yield the status
            yield fwpb2.ExecutionInfo(**return_values)
    
    def SetFillLevel_Result(self, request, context) -> pb2.SetFillLevel_Responses:
        """
        Returns the final result of the command call :meth:`~.SetFillLevel`.
    
        :param request: A request object with the following properties
            CommandExecutionUUID: The UUID of the command executed.
        :param context: gRPC :class:`~grpc.ServicerContext` object providing gRPC-specific information
    
        :returns: The return object defined for the command with the following fields:
            request.Success (Success): A boolean value where false means that the dosage failed and true meaning the dosage was finished properly.
        """
    
        # initialise the return value
        return_value: pb2.SetFillLevel_Responses = None
    
        # Get the UUID of the command
        command_uuid = request.commandId
    
        # TODO:
        #   Add implementation of Real for command SetFillLevel here and write the resulting response
        #   in return_value
    
        # fallback to default
        if return_value is None:
            return_value = pb2.SetFillLevel_Responses(
                **default_dict['SetFillLevel_Responses']
            )
    
        return return_value
    
    
    def DoseVolume(self, request, context) -> fwpb2.CommandConfirmation:
        """
        Executes the observable command Dose Volume
            Dose a certain amount of volume with the given flow rate.
    
        :param request: gRPC request containing the parameters passed:
            request.Volume (Volume): The amount of volume to dose.
            request.FlowRate (Flow Rate):
            The flow rate at which the pump should dose the fluid. This value can be negative. In that case the pump aspirates the fluid.
        :param context: gRPC :class:`~grpc.ServicerContext` object providing gRPC-specific information
    
        :returns: A command confirmation object with the following information:
            commandId: A command id with which this observable command can be referenced in future calls
            lifetimeOfExecution: The (maximum) lifetime of this command call.
        """
    
        # initialise default values
        #: Duration fwpb2.Duration(seconds=<seconds>, nanos=<nanos>)
        lifetime_of_execution: fwpb2.Duration = None
    
        # TODO:
        #   Execute the actual command
        #   Optional: Generate a lifetime_of_execution
    
        # respond with UUID and lifetime of execution
        command_uuid = fwpb2.CommandExecutionUUID(commandId=str(uuid.uuid4()))
        if lifetime_of_execution is not None:
            return fwpb2.CommandConfirmation(
                commandId=command_uuid,
                lifetimeOfExecution=lifetime_of_execution
            )
        else:
            return fwpb2.CommandConfirmation(
                commandId=command_uuid
            )
    
    def DoseVolume_Info(self, request, context) -> fwpb2.ExecutionInfo:
        """
        Returns execution information regarding the command call :meth:`~.DoseVolume`.
    
        :param request: A request object with the following properties
            commandId: The UUID of the command executed.
        :param context: gRPC :class:`~grpc.ServicerContext` object providing gRPC-specific information
    
        :returns: An ExecutionInfo response stream for the command with the following fields:
            commandStatus: Status of the command (enumeration)
            progressInfo: Information on the progress of the command (0 to 1)
            estimatedRemainingTime: Estimate of the remaining time required to run the command
            updatedLifetimeOfExecution: An update on the execution lifetime
        """
        # Get the UUID of the command
        command_uuid = request.commandId
    
        # Get the current state
        execution_info = self._get_command_state(command_uuid=command_uuid)
    
        # construct the initial return dictionary in case while is not executed
        return_values = {'commandStatus': execution_info.commandStatus}
        if execution_info.HasField('progressInfo'):
            return_values['progressInfo'] = execution_info.progressInfo
        if execution_info.HasField('estimatedRemainingTime'):
            return_values['estimatedRemainingTime'] = execution_info.estimatedRemainingTime
        if execution_info.HasField('updatedLifetimeOfExecution'):
            return_values['updatedLifetimeOfExecution'] = execution_info.updatedLifetimeOfExecution
    
        # we loop only as long as the command is running
        while execution_info.commandStatus == fwpb2.ExecutionInfo.CommandStatus.waiting \
                or execution_info.commandStatus == fwpb2.ExecutionInfo.CommandStatus.running:
            # TODO:
            #   Evaluate the command status --> command_status. Options:
            #       command_stats = fwpb2.ExecutionInfo.CommandStatus.waiting
            #       command_stats = fwpb2.ExecutionInfo.CommandStatus.running
            #       command_stats = fwpb2.ExecutionInfo.CommandStatus.finishedSuccessfully
            #       command_stats = fwpb2.ExecutionInfo.CommandStatus.finishedWithError
            #   Optional:
            #       * Determine the progress (progressInfo)
            #       * Determine the estimated remaining time
            #       * Update the Lifetime of execution
    
            # Update all values
            execution_info = self._get_command_state(command_uuid=command_uuid)
    
            # construct the return dictionary
            return_values = {'commandStatus': execution_info.commandStatus}
            if execution_info.HasField('progressInfo'):
                return_values['progressInfo'] = execution_info.progressInfo
            if execution_info.HasField('estimatedRemainingTime'):
                return_values['estimatedRemainingTime'] = execution_info.estimatedRemainingTime
            if execution_info.HasField('updatedLifetimeOfExecution'):
                return_values['updatedLifetimeOfExecution'] = execution_info.updatedLifetimeOfExecution
    
            yield fwpb2.ExecutionInfo(**return_values)
    
            # we add a small delay to give the client a chance to keep up.
            time.sleep(0.5)
        else:
            # one last time yield the status
            yield fwpb2.ExecutionInfo(**return_values)
    
    def DoseVolume_Result(self, request, context) -> pb2.DoseVolume_Responses:
        """
        Returns the final result of the command call :meth:`~.DoseVolume`.
    
        :param request: A request object with the following properties
            CommandExecutionUUID: The UUID of the command executed.
        :param context: gRPC :class:`~grpc.ServicerContext` object providing gRPC-specific information
    
        :returns: The return object defined for the command with the following fields:
            request.Success (Success): A boolean value where false means that the dosage failed and true meaning the dosage was finished properly.
        """
    
        # initialise the return value
        return_value: pb2.DoseVolume_Responses = None
    
        # Get the UUID of the command
        command_uuid = request.commandId
    
        # TODO:
        #   Add implementation of Real for command DoseVolume here and write the resulting response
        #   in return_value
    
        # fallback to default
        if return_value is None:
            return_value = pb2.DoseVolume_Responses(
                **default_dict['DoseVolume_Responses']
            )
    
        return return_value
    
    
    def GenerateFlow(self, request, context) -> fwpb2.CommandConfirmation:
        """
        Executes the observable command Generate Flow
            Generate a continous flow with the given flow rate. Dosing continues until it gets stopped manually by calling StopDosage or until the pusher reached one of its limits.
    
        :param request: gRPC request containing the parameters passed:
            request.FlowRate (Flow Rate):
            The flow rate at which the pump should dose the fluid. This value can be negative. In that case the pump aspirates the fluid.
        :param context: gRPC :class:`~grpc.ServicerContext` object providing gRPC-specific information
    
        :returns: A command confirmation object with the following information:
            commandId: A command id with which this observable command can be referenced in future calls
            lifetimeOfExecution: The (maximum) lifetime of this command call.
        """
    
        # initialise default values
        #: Duration fwpb2.Duration(seconds=<seconds>, nanos=<nanos>)
        lifetime_of_execution: fwpb2.Duration = None
    
        # TODO:
        #   Execute the actual command
        #   Optional: Generate a lifetime_of_execution
    
        # respond with UUID and lifetime of execution
        command_uuid = fwpb2.CommandExecutionUUID(commandId=str(uuid.uuid4()))
        if lifetime_of_execution is not None:
            return fwpb2.CommandConfirmation(
                commandId=command_uuid,
                lifetimeOfExecution=lifetime_of_execution
            )
        else:
            return fwpb2.CommandConfirmation(
                commandId=command_uuid
            )
    
    def GenerateFlow_Info(self, request, context) -> fwpb2.ExecutionInfo:
        """
        Returns execution information regarding the command call :meth:`~.GenerateFlow`.
    
        :param request: A request object with the following properties
            commandId: The UUID of the command executed.
        :param context: gRPC :class:`~grpc.ServicerContext` object providing gRPC-specific information
    
        :returns: An ExecutionInfo response stream for the command with the following fields:
            commandStatus: Status of the command (enumeration)
            progressInfo: Information on the progress of the command (0 to 1)
            estimatedRemainingTime: Estimate of the remaining time required to run the command
            updatedLifetimeOfExecution: An update on the execution lifetime
        """
        # Get the UUID of the command
        command_uuid = request.commandId
    
        # Get the current state
        execution_info = self._get_command_state(command_uuid=command_uuid)
    
        # construct the initial return dictionary in case while is not executed
        return_values = {'commandStatus': execution_info.commandStatus}
        if execution_info.HasField('progressInfo'):
            return_values['progressInfo'] = execution_info.progressInfo
        if execution_info.HasField('estimatedRemainingTime'):
            return_values['estimatedRemainingTime'] = execution_info.estimatedRemainingTime
        if execution_info.HasField('updatedLifetimeOfExecution'):
            return_values['updatedLifetimeOfExecution'] = execution_info.updatedLifetimeOfExecution
    
        # we loop only as long as the command is running
        while execution_info.commandStatus == fwpb2.ExecutionInfo.CommandStatus.waiting \
                or execution_info.commandStatus == fwpb2.ExecutionInfo.CommandStatus.running:
            # TODO:
            #   Evaluate the command status --> command_status. Options:
            #       command_stats = fwpb2.ExecutionInfo.CommandStatus.waiting
            #       command_stats = fwpb2.ExecutionInfo.CommandStatus.running
            #       command_stats = fwpb2.ExecutionInfo.CommandStatus.finishedSuccessfully
            #       command_stats = fwpb2.ExecutionInfo.CommandStatus.finishedWithError
            #   Optional:
            #       * Determine the progress (progressInfo)
            #       * Determine the estimated remaining time
            #       * Update the Lifetime of execution
    
            # Update all values
            execution_info = self._get_command_state(command_uuid=command_uuid)
    
            # construct the return dictionary
            return_values = {'commandStatus': execution_info.commandStatus}
            if execution_info.HasField('progressInfo'):
                return_values['progressInfo'] = execution_info.progressInfo
            if execution_info.HasField('estimatedRemainingTime'):
                return_values['estimatedRemainingTime'] = execution_info.estimatedRemainingTime
            if execution_info.HasField('updatedLifetimeOfExecution'):
                return_values['updatedLifetimeOfExecution'] = execution_info.updatedLifetimeOfExecution
    
            yield fwpb2.ExecutionInfo(**return_values)
    
            # we add a small delay to give the client a chance to keep up.
            time.sleep(0.5)
        else:
            # one last time yield the status
            yield fwpb2.ExecutionInfo(**return_values)
    
    def GenerateFlow_Result(self, request, context) -> pb2.GenerateFlow_Responses:
        """
        Returns the final result of the command call :meth:`~.GenerateFlow`.
    
        :param request: A request object with the following properties
            CommandExecutionUUID: The UUID of the command executed.
        :param context: gRPC :class:`~grpc.ServicerContext` object providing gRPC-specific information
    
        :returns: The return object defined for the command with the following fields:
            request.Success (Success): A boolean value where false means that the dosage failed and true meaning the dosage was finished properly.
        """
    
        # initialise the return value
        return_value: pb2.GenerateFlow_Responses = None
    
        # Get the UUID of the command
        command_uuid = request.commandId
    
        # TODO:
        #   Add implementation of Real for command GenerateFlow here and write the resulting response
        #   in return_value
    
        # fallback to default
        if return_value is None:
            return_value = pb2.GenerateFlow_Responses(
                **default_dict['GenerateFlow_Responses']
            )
    
        return return_value
    
    
    def StopDosage(self, request, context) -> pb2.StopDosage_Responses:
        """
        Executes the unobservable command Stop Dosage
            Stops a currently running dosage immediately.
    
        :param request: gRPC request containing the parameters passed:
            request.EmptyParameter (Empty Parameter): An empty parameter data type used if no parameter is required.
        :param context: gRPC :class:`~grpc.ServicerContext` object providing gRPC-specific information
    
        :returns: The return object defined for the command with the following fields:
            request.Success (Success): A boolean value where false means that stopping the dosage failed and true meaning the dosage was stopped properly.
        """
    
        # initialise the return value
        return_value = None
    
        # TODO:
        #   Add implementation of Real for command StopDosage here and write the resulting response
        #   in return_value
    
        # fallback to default
        if return_value is None:
            return_value = pb2.StopDosage_Responses(
                **default_dict['StopDosage_Responses']
            )
    
        return return_value

    def Get_MaxSyringeFillLevel(self, request, context) -> pb2.Get_MaxSyringeFillLevel_Responses:
        """
        Requests the unobservable property Maximum Syringe Fill Level
            The maximum amount of fluid that the syringe can hold.
    
        :param request: An empty gRPC request object (properties have no parameters)
        :param context: gRPC :class:`~grpc.ServicerContext` object providing gRPC-specific information
    
        :returns: A response object with the following fields:
            request.MaxSyringeFillLevel (Maximum Syringe Fill Level): The maximum amount of fluid that the syringe can hold.
        """
    
        # initialise the return value
        return_value: pb2.Get_MaxSyringeFillLevel_Responses = None
    
        # TODO:
        #   Add implementation of Real for property MaxSyringeFillLevel here and write the resulting response
        #   in return_value
    
        # fallback to default
        if return_value is None:
            return_value = pb2.Get_MaxSyringeFillLevel_Responses(
                **default_dict['Get_MaxSyringeFillLevel_Responses']
            )
    
        return return_value
    
    def Subscribe_SyringeFillLevel(self, request, context) -> pb2.Subscribe_SyringeFillLevel_Responses:
        """
        Requests the observable property Syringe Fill Level
            The current amount of fluid left in the syringe.
    
        :param request: An empty gRPC request object (properties have no parameters)
        :param context: gRPC :class:`~grpc.ServicerContext` object providing gRPC-specific information
    
        :returns: A response object with the following fields:
            request.SyringeFillLevel (Syringe Fill Level): The current amount of fluid left in the syringe.
        """
    
        # initialise the return value
        return_value: pb2.Subscribe_SyringeFillLevel_Responses = None
    
        # create the default value
        if return_value is None:
            return_value = pb2.Subscribe_SyringeFillLevel_Responses(
                **default_dict['Subscribe_SyringeFillLevel_Responses']
            )
    
        # we could use a timeout here if we wanted
        while True:
            # TODO:
            #   Add implementation of Real for property SyringeFillLevel here and write the resulting
            #   response in return_value
    
            yield return_value
    
    
    def Get_MaxFlowRate(self, request, context) -> pb2.Get_MaxFlowRate_Responses:
        """
        Requests the unobservable property Maximum Flow Rate
            The maximum value of the flow rate at which this pump can dose a fluid.
    
        :param request: An empty gRPC request object (properties have no parameters)
        :param context: gRPC :class:`~grpc.ServicerContext` object providing gRPC-specific information
    
        :returns: A response object with the following fields:
            request.MaxFlowRate (Maximum Flow Rate): The maximum value of the flow rate at which this pump can dose a fluid.
        """
    
        # initialise the return value
        return_value: pb2.Get_MaxFlowRate_Responses = None
    
        # TODO:
        #   Add implementation of Real for property MaxFlowRate here and write the resulting response
        #   in return_value
    
        # fallback to default
        if return_value is None:
            return_value = pb2.Get_MaxFlowRate_Responses(
                **default_dict['Get_MaxFlowRate_Responses']
            )
    
        return return_value
    
    def Subscribe_FlowRate(self, request, context) -> pb2.Subscribe_FlowRate_Responses:
        """
        Requests the observable property Flow Rate
            The current value of the flow rate. It is 0 if the pump does not dose any fluid.
    
        :param request: An empty gRPC request object (properties have no parameters)
        :param context: gRPC :class:`~grpc.ServicerContext` object providing gRPC-specific information
    
        :returns: A response object with the following fields:
            request.FlowRate (Flow Rate): The current value of the flow rate. It is 0 if the pump does not dose any fluid.
        """
    
        # initialise the return value
        return_value: pb2.Subscribe_FlowRate_Responses = None
    
        # create the default value
        if return_value is None:
            return_value = pb2.Subscribe_FlowRate_Responses(
                **default_dict['Subscribe_FlowRate_Responses']
            )
    
        # we could use a timeout here if we wanted
        while True:
            # TODO:
            #   Add implementation of Real for property FlowRate here and write the resulting
            #   response in return_value
    
            yield return_value
    
